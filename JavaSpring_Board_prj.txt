Part2.ch02.03
 - JPA Auditing
  -> JpaConfig에 @달아주는걸로 사용
 - 엔티티에서 생성자에서 원래 넣어야 되는 도매인과 관련이 있는 정보만 오픈하는 방식으로 해서
   생성자를 통해 만들 수 있게 유도, 여기서 더 나아가,
   생성자를 private으로 막아버리고, Factory Method를 통해 제공할 수 있게 하기.
  -> New 키워드를 쓰지 않고 쓸 수 있게, 즉 사용 편하게.
  -> public static article of로 의도 전달
 - lombok의 equals hashcode를 사용하지 않는 이유는, id만 비교하면 되고 다른 부분은 비교하지 않아도 되기 때문에
 - equals hashcode를 만들어도, id가 당연히 not null이라고 생각하고 equals를 하고 있지만,
   id가 null일 수 있음. 아직 영속화를 하지 않았을 때, 즉 데이터베이스에 데이터를 연결시키지 않았을 때,
   아직 인서트하기 전에 만든 엔티티는 id를 부여받지 않는다. 그래서 null이다. 따라서 이 부분을 체크해줘야 함.
  -> id != null &&
  -> 즉, 지금 막 만든 아직 영속화되지 않은 엔티티는 모두 동등성 검사를 탈락한다. 즉,
      모두 각 다른 값으로 보겠다. 모든 새로 만든 엔티티들이 아직 영속화 되지 않았다면 
      '내용이 동일하다고 하더라도' 다른 값으로 취급하겠다. 라는 것
 - JPA 버디의 다양한 편리한 기능 사용

Part2.ch02.03
 - cascade, 실무에서는 양방향 바인딩을 일부러 풀고 디자인을 하는 경우가 많다.
  -> 왜냐? cascading에 의해 서로가 강하게 결합된다.
  -> 그래서 데이터를 마이그레이션 하거나 쉽게 어드밴해서 편집을 하거나 할 때 불편함이 따른다.
  -> 원치 않는 데이터 소실이 일어날 수도.
  -> Ex) 논리상으로 게시글이 지워지면 딸려있는 댓글도 사라져야 되는게 맞지만, 운영은 다르다.
           게시글은 사라지더라도 댓글은 백업 목적으로 남기고 싶을 수도.
          하지만 cascading을 delete 걸면 게시글을 삭제할 때 연관된 댓글들이 알아서 자동으로 삭제됨.
          운영 입장에서는 불상사
  -> 따라서 일부러 연관관계, foreign key를 안 걸고, 또 퍼포먼스적인 이슈 때문에도
      foreign key를 일부러 안 걸고 운영하는 경우도 많다.
 - 순환참조 - @ToString
  -> circular referencing(?) 이슈가 생길 수 있음.
  -> @ToString이 모든 원소들을 @ToString 찍기 위해 다 조회한다. title, content, hashtag 등등.
  -> articleComments있으니까 찍으려고 하는데, collection 들어가서  article comment 안으로 들어가서
  -> 또 @ToString을 보려할 것임.
  -> 근데 그 친구도 @ToString이 있음. 그럼 각 필드를 다 찍으려고 하는데,
  -> article을 가지고 있음. article 안에 들어가서 내용을 또 찍어야함
  -> 또 @ToString이 있음. 이안 에 또 set articlecomment, 
  -> articlecomment는 또 aritlcle을 보고
  -> 이렇 것이 순환참조. 이런 문제로 인해 메모리가 om으로 뻗어버리고 시스템이 중단될 수도.
  -> 따라서 반드시 둘 중 한 곳의 연결고리를 끊어줘야함.
  -> toString으로 끊는다면 보통 article을 끊어줌. 
  -> 이유는, 댓글로부터 글을 참조하는 경우는 정상적인데, article에서 댓글 리스트를 다 뽑아보는건
  -> 굳이 그렇게 보지 않아도됨. 따라서 article을 끊어주는 것이 좀 더 조리있는 방식

Part2.ch02.04
 - 테스트 데이터를 대량으로 생성해주는 서비스이용
  -> mockaroo.com

Part2.ch02.05
 - rest repository와, rest repository hal explorer 이용
 - data rest 기능은 rest repository로 끝난거지만, 시각적으로 편하게 보고, 테스트도 편하게 하고 싶을 때,
  - 웹 서비스를 하나 오픈할건데, 미리 만들어진 것.
  - 따라서 HAL Explorer를 이용해서 간단하게 우리가 만든  api를 테스트해볼 수 있음
 -  DB 접근이 일어나므로 안전을 위해 '@Transaction' 추가,테스트 안에서는 RollBack 정책으로 동작

Part2.ch02.06
 - 검색기능 구현하며, Query DSL 연동시키는 방법,
 - SpringBoot, SpringDataJPA, QueryDSL의 연계기능 어떤식으로 서비스 제공되고 있는지.
 - QueryDSL Predicate Executor, Query DSL Binder Customizer
  -> QueryDSL Predicate Executor : 이 엔티티 안에 있는 모든 필드에 대한 기본 검색 기능을 추가, 사실상 이것만 잇어도 검색기능 끝나는 수준
   -> 하지만 부분 검색이 안됨.
   -> 따라서 입맛에 맞는 검색을 위해 Query DSL Binder Customizer 사용
   ->customize를 Override해서.
 - QueryDSL이 자동으로 클래스를 생성하는 기능 -> Qclass라고함

Part2.ch02.07
 - 본 코드에서는 @Autowired 생략가능하지만, Test에서는 @Autowired 생략 불가능
 - Jnit5의 @Disabled를 이용해 단위테스트에서 제외시킬 수 있음
  -> 테스트가 통과안되면 build가 실패하기 때문에 제외시킬 때 사용
  -> 기존 테스트를 실패한 채 올리면 `gradle build`가 실패하여 배포 자동화에 악영향이 있어, 실패 테스트는 테스트 제외 처리하는 방향 적용하기 위해, 기능 구현 중인 유닛 테스트를 모두 `@Disabled`처리

Part2.ch02.08
 - 게시판 페이지 만들기
  -> Semantic tag 사용 -> header, body, footer ...

Part2.ch02.09,10
 - github 리베이스 앤 머지 전략
 - start.spring.io에서 타임리프와 시큐리티를 같이 담아서 디펜더시를 가져온다.
 - 로그인 페이지가 만들어져있음. 따로 만들지 않아도.
 - Security Configuration이 2.7버전되면서, 원래는 extends로 WebSecurityConfigurerAdapter를 햇었는데,
   컴포넌트 빈으로 하게 바뀜. 장려

Part2.ch02.11
 - bootstrap에서 좀 더 이쁜 페이지를 위한 페이지 -> bootdey.com 추천

